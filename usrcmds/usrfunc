# User configuration
usrconfpath=~/.bash_usrconf
usrconf() {
  __reinit() {
    . ~/.bashrc
  }
  OPTIND=1
  while getopts ":r-:" opt
  do
    case "$opt" in
      "-")  # check for long parameters
        case "$OPTARG" in
          reinit) __reinit; return 0;;
          *) echo "usrconf: Ungültige Option -- $OPTARG"; return 1;
        esac;;
      r) __reinit; return 0;;
      *) echo "usrconf: Ungültige Option -- $OPTARG"; return 1;;
    esac
  done
  cd "$usrconfpath"
}
# Change user configuration files which are indexed by find-command.
:e() {
  cd "$usrconfpath"
  echo "Indexing files in dir $usrconfpath..."
  i=1
  for f in $(find); do
    if [[ "${f:0:6}" != "./.git" && "$f" != "./README.md" && ! -d "$f" ]]; then
      echo "$i ${f:2}"
      i=$[i+1]
    fi
  done
  read -p "Which file do you want to edit? : " input
  # Check if input is valid
  regex="^-?[0-9]+$"
  if [[ ! "$input" =~ $regex ]]; then
    echo "Not a number."
    return 1
  fi
  if [[ "$input" -lt 1 || "$input" -gt "$[i-1]" ]]; then
    echo "Not a valid number."
    return 1
  fi
  # NOTE This is not very efficient. Save lines in previous for-loop in an array
  # and access the files that way not by looping again.
  i=1
  for f in $(find); do
    if [[ "${f:0:6}" != "./.git" && "$f" != "./README.md" && ! -d "$f" ]]; then
      if [[ "$i" == "$input" ]]; then
        cd "$OLDPWD"
        echo "running subl $usrconfpath/${f:2}"
        subl "$usrconfpath/${f:2}"
        return 0
      fi
      i=$[i+1]
    fi
  done
}
# Interactive cd
cdi() {
  count=1;
  for l in $(ls -a --group-directories-first); do
    if [[ -d "$l" && "$l" != "." ]]; then
      echo "$count $l"
      count=$[count+1]
    fi
  done
  read -p "Select dir for cd [cancel: c or ENTER]: " input;
  # Check for cancel value
  if [[ "$input" == "" || "$input" == "c" ]]; then
    return 0
  fi
  # Check if input is valid
  regex="^-?[0-9]+$"
  if [[ ! "$input" =~ $regex ]]; then
    echo "Not a number."
    return 1
  fi
  if [[ "$input" -lt 1 || "$input" -gt "$[count-1]" ]]; then
    echo "Not a valid number."
    return 1
  fi
  # Add 1 to input since '.' is first output of ls and we did skip it
  cd $(ls -a --group-directories-first | head -$[input+1] | tail -1)
  echo "You are now in directory: $PWD"
  # Rerun function because user may want to cd further
  cdi
}
